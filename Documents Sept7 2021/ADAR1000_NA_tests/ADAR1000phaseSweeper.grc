options:
  parameters:
    author: ''
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: top_block
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Beamformer_Ex4
    window_size: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: ADAR_address
  id: variable_qtgui_chooser
  parameters:
    comment: ''
    gui_hint: ControlTab@0:0,0,1,2
    label: ADDR
    label0: '0x00'
    label1: '0x20'
    label2: '0x40'
    label3: '0x60'
    label4: ''
    labels: '[]'
    num_opts: '4'
    option0: '0'
    option1: '1'
    option2: '2'
    option3: '3'
    option4: '4'
    options: '[0, 1, 2]'
    orient: Qt.QHBoxLayout
    type: int
    value: '1'
    widget: radio_buttons
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [631, 304]
    rotation: 0
    state: true
- name: ADAR_mode
  id: variable_qtgui_chooser
  parameters:
    comment: ''
    gui_hint: ControlTab@0:1,0,1,2
    label: ''
    label0: Transmit
    label1: Receive
    label2: '0x40'
    label3: '0x60'
    label4: ''
    labels: '[]'
    num_opts: '2'
    option0: '0'
    option1: '1'
    option2: '2'
    option3: '3'
    option4: '4'
    options: '[0, 1, 2]'
    orient: Qt.QHBoxLayout
    type: int
    value: '1'
    widget: radio_buttons
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [765, 321]
    rotation: 0
    state: true
- name: BeamTaper
  id: variable_qtgui_check_box
  parameters:
    comment: ''
    'false': '0'
    gui_hint: ControlTab@1:4,0
    label: Set All Element Gains to Max (127)
    'true': '1'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1245, -3]
    rotation: 0
    state: enabled
- name: IgnorePhaseCals
  id: variable_qtgui_check_box
  parameters:
    comment: ''
    'false': '0'
    gui_hint: ControlTab@2:4,0,1,2
    label: Set All Phase Cals to 0 deg
    'true': '1'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 124]
    rotation: 0
    state: enabled
- name: Rx1Gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@1:0,0,1,2
    label: Gain1
    min_len: '20'
    orient: Qt.Horizontal
    rangeType: int
    start: '0'
    step: '1'
    stop: '127'
    value: '127'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 20]
    rotation: 0
    state: enabled
- name: Rx1_Cal
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@2:0,0,1,2
    label: Phase1
    min_len: '10'
    orient: Qt.Horizontal
    rangeType: float
    start: '-180'
    step: '2.8125'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 132]
    rotation: 0
    state: enabled
- name: Rx2Gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@1:1,0,1,2
    label: Gain2
    min_len: '20'
    orient: Qt.Horizontal
    rangeType: int
    start: '0'
    step: '1'
    stop: '127'
    value: '127'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 20]
    rotation: 0
    state: enabled
- name: Rx2_Cal
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@2:1,0,1,2
    label: Phase2
    min_len: '10'
    orient: Qt.Horizontal
    rangeType: float
    start: '-180'
    step: '2.8125'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 132]
    rotation: 0
    state: enabled
- name: Rx3Gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@1:2,0,1,2
    label: Gain3
    min_len: '20'
    orient: Qt.Horizontal
    rangeType: int
    start: '0'
    step: '1'
    stop: '127'
    value: '127'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [784, 20]
    rotation: 0
    state: enabled
- name: Rx3_Cal
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@2:2,0,1,2
    label: Phase3
    min_len: '10'
    orient: Qt.Horizontal
    rangeType: float
    start: '-180'
    step: '2.8125'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [784, 132]
    rotation: 0
    state: enabled
- name: Rx4Gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@1:3,0,1,2
    label: Gain4
    min_len: '20'
    orient: Qt.Horizontal
    rangeType: int
    start: '0'
    step: '1'
    stop: '127'
    value: '127'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [920, 20]
    rotation: 0
    state: enabled
- name: Rx4_Cal
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ControlTab@2:3,0,1,2
    label: Phase4
    min_len: '10'
    orient: Qt.Horizontal
    rangeType: float
    start: '-180'
    step: '2.8125'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [920, 132]
    rotation: 0
    state: enabled
- name: Setup_ADAR1000
  id: variable_qtgui_push_button
  parameters:
    comment: ''
    gui_hint: ControlTab@0:2,0,1,2
    label: Setup the ADAR1000
    pressed: '1'
    released: '0'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [917, 312]
    rotation: 0
    state: true
- name: SymmetricTaper
  id: variable_qtgui_check_box
  parameters:
    comment: ''
    'false': '0'
    gui_hint: ControlTab@1:5,0
    label: Set Gain4 = Gain1 (Symmetric Taper)
    'true': '1'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1056, 4]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '40000000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [197, 18]
    rotation: 0
    state: enabled
- name: variable_qtgui_label_0
  id: variable_qtgui_label
  parameters:
    comment: ''
    formatter: None
    gui_hint: ControlTab@0:3,0,6,2
    label: ' '
    type: string
    value: ' '
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [917, 427]
    rotation: 0
    state: true
- name: ControlTab
  id: qtgui_tab_widget
  parameters:
    alias: ''
    comment: ''
    gui_hint: 0,0,6,2
    label0: ADAR1000_Setup
    label1: Gain
    label10: Tab 10
    label11: Tab 11
    label12: Tab 12
    label13: Tab 13
    label14: Tab 14
    label15: Tab 15
    label16: Tab 16
    label17: Tab 17
    label18: Tab 18
    label19: Tab 19
    label2: Phase
    label3: Bandwidth
    label4: Tab 4
    label5: Tab 5
    label6: Tab 6
    label7: Tab 7
    label8: Tab 8
    label9: Tab 9
    num_tabs: '3'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [30, 117]
    rotation: 0
    state: enabled
- name: blocks_null_sink_0
  id: blocks_null_sink
  parameters:
    affinity: ''
    alias: ''
    bus_structure_sink: '[[0,],]'
    comment: ''
    num_inputs: '1'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [412, 520]
    rotation: 0
    state: true
- name: blocks_throttle_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [239, 510]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    PhaseCal: int(IgnorePhaseCals)
    Rx1_cal: Rx1_Cal
    Rx2_cal: Rx2_Cal
    Rx3_cal: Rx3_Cal
    Rx4_cal: Rx4_Cal
    RxGain1: int(Rx1Gain)
    RxGain2: int(Rx2Gain)
    RxGain3: int(Rx3Gain)
    RxGain4: int(Rx4Gain)
    SignalFreq: int((10107000-0)*1000000)
    SymTaper: int(SymmetricTaper)
    Taper: int(BeamTaper)
    _source_code: "# ADAR1000 Phase Sweeper and Pluto data collection\n\n'''\nUseful\
      \ resources:\n    Introduction to Phased Array Antennas: https://www.analog.com/en/analog-dialogue/articles/phased-array-antenna-patterns-part1.html#\n\
      \    Full workshop build instructions at www.github.com/jonkraft/phasedarray\n\
      \    Analog Devices Python Interfaces:  https://analogdevicesinc.github.io/pyadi-iio/\n\
      \    Python examples:  https://github.com/analogdevicesinc/pyadi-iio/tree/master/examples\n\
      \    GNU Radio and IIO Devices:  https://wiki.analog.com/resources/tools-software/linux-software/gnuradio\n\
      \    ADI Kuiper Linux for Raspberry Pi:  https://wiki.analog.com/resources/tools-software/linux-software/gnuradio\n\
      '''\n\n# Copyright (C) 2019 Analog Devices, Inc.\n#\n# All rights reserved.\n\
      #\n# Redistribution and use in source and binary forms, with or without modification,\n\
      # are permitted provided that the following conditions are met:\n#     - Redistributions\
      \ of source code must retain the above copyright\n#       notice, this list\
      \ of conditions and the following disclaimer.\n#     - Redistributions in binary\
      \ form must reproduce the above copyright\n#       notice, this list of conditions\
      \ and the following disclaimer in\n#       the documentation and/or other materials\
      \ provided with the\n#       distribution.\n#     - Neither the name of Analog\
      \ Devices, Inc. nor the names of its\n#       contributors may be used to endorse\
      \ or promote products derived\n#       from this software without specific prior\
      \ written permission.\n#     - The use of this software may or may not infringe\
      \ the patent rights\n#       of one or more patent holders.  This license does\
      \ not release you\n#       from the requirement that you obtain separate licenses\
      \ from these\n#       patent holders to use this software.\n#     - Use of the\
      \ software either in source or binary form, must be run\n#       on or directly\
      \ connected to an Analog Devices Inc. component.\n#\n# THIS SOFTWARE IS PROVIDED\
      \ BY ANALOG DEVICES \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n# INCLUDING,\
      \ BUT NOT LIMITED TO, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A\n\
      # PARTICULAR PURPOSE ARE DISCLAIMED.\n#\n# IN NO EVENT SHALL ANALOG DEVICES\
      \ BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR\
      \ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, INTELLECTUAL PROPERTY\n\
      # RIGHTS, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\
      \ PROFITS; OR\n# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\
      \ LIABILITY, WHETHER IN CONTRACT,\n# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\
      \ OR OTHERWISE) ARISING IN ANY WAY OUT OF\n# THE USE OF THIS SOFTWARE, EVEN\
      \ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nimport numpy as np\nimport\
      \ time\nimport spidev\nfrom gnuradio import gr\nimport sys\n\ndef ADAR_init(spi,\
      \ ADDR, Rx_mode):\n    # Initialize the ADAR1000\n    spi.xfer2([ADDR, 0x00,\
      \ 0x81])  # reset the device\n    spi.xfer2([ADDR, 0x00, 0x18])  # Sets SDO\
      \  pin to active (4 wire SPI)\n    spi.xfer2([ADDR+0x04, 0x00, 0x55])  # Trims\
      \ LDO to 1.8V\n    spi.xfer2([ADDR, 0x38, 0x60])  # Bypasses beam and bias RAM\
      \ (use SPI for gain/phase)\n    if Rx_mode == 1:\n        print(\"ADAR1000 is\
      \ in Rx Mode\")\n        spi.xfer2([ADDR, 0x2E, 0x7F])  # Enables all 4 Rx channels,\
      \ LNA, VGA, and Vector Mod\n        spi.xfer2([ADDR, 0x34, 0x08])  # Sets LNA\
      \ bias to middle of its range\n        spi.xfer2([ADDR, 0x35, 0x16])  # Sets\
      \ VGA bias to [0010] and vector mod bias to [110]\n        spi.xfer2([ADDR,\
      \ 0x31, 0xB0])  # Enables the whole Rx and sets the ADTR1107 switch high (Rx\
      \ mode)\n        spi.xfer2([ADDR, 0x10, int(128+127)])  # Sets Rx1 VGA gain\n\
      \        spi.xfer2([ADDR, 0x11, int(128+127)])  # Sets Rx2 VGA gain\n      \
      \  spi.xfer2([ADDR, 0x12, int(128+127)])  # Sets Rx3 VGA gain\n        spi.xfer2([ADDR,\
      \ 0x13, int(128+127)])  # Sets Rx4 VGA gain\n    else:\n        print(\"ADAR1000\
      \ is in Tx Mode\")\n        spi.xfer2([ADDR, 0x2F, 0x7F])  # Enables all four\
      \ Tx channels, the Tx Driver, Tx Vector Modulator and Tx VGA\n        spi.xfer2([ADDR,\
      \ 0x36, 0x16])  # Sets the TX VGA bias to [0010] and the TX vector modulator\
      \ bias to [110]\n        spi.xfer2([ADDR, 0x37, 0x06])  # Sets the Tx Driver\
      \ bias to [110]\n        #spi.xfer2([ADDR, 0x31, 0x42])  # Enables the whole\
      \ Tx and enable TR_SPI\n        spi.xfer2([ADDR, 0x31, 0xD0])  # Enables Tx\
      \ and the switch, but puts part into Rx mode until we bias the PA's properly.\
      \  TR_SW_POS should be at 3.3V now\n        spi.xfer2([ADDR, 0x30, 0x40])  #\
      \ Sets bit 6 high (enables control of pins for external biasing)\n        spi.xfer2([ADDR,\
      \ 0x29, 0x39])  # Sets \"on\" PA gate bias to about -1.1V\n        spi.xfer2([ADDR,\
      \ 0x2A, 0x39])  # Sets \"on\" PA gate bias to about -1.1V\n        spi.xfer2([ADDR,\
      \ 0x2B, 0x39])  # Sets \"on\" PA gate bias to about -1.1V\n        spi.xfer2([ADDR,\
      \ 0x2C, 0x39])  # Sets \"on\" PA gate bias to about -1.1V\n        spi.xfer2([ADDR,\
      \ 0x46, 0x68])  # Sets \"off\" PA gate bias to about -2V\n        spi.xfer2([ADDR,\
      \ 0x47, 0x68])  # Sets \"off\" PA gate bias to about -2V\n        spi.xfer2([ADDR,\
      \ 0x48, 0x68])  # Sets \"off\" PA gate bias to about -2V\n        spi.xfer2([ADDR,\
      \ 0x49, 0x68])  # Sets \"off\" PA gate bias to about -2V\n        spi.xfer2([ADDR,\
      \ 0x31, 0x90])  # Changes Reg 0x31 to TX_EN=0.  PA_BIAS should be at -2V now.\
      \    \n\n        # Write registers to set Tx1-4 to 45 deg and Max Gain\n   \
      \     spi.xfer2([ADDR, 0x1C, 128])  # Sets Tx1 gain\n        spi.xfer2([ADDR,\
      \ 0x20, 0x3F])  # Sets Tx1 I vector to positive and [10110]\n        spi.xfer2([ADDR,\
      \ 0x21, 0x20])  # Sets Tx1 Q vector to positive and [10110]\n        spi.xfer2([ADDR,\
      \ 0x1D, 128])  # Sets Tx2 gain\n        spi.xfer2([ADDR, 0x22, 0x3F])  # Sets\
      \ Tx2 I vector to positive and [10110]\n        spi.xfer2([ADDR, 0x23, 0x20])\
      \  # Sets Tx2 Q vector to positive and [10110]\n        spi.xfer2([ADDR, 0x1E,\
      \ 128])  # Sets Tx3 gain\n        spi.xfer2([ADDR, 0x24, 0x3F])  # Sets Tx3\
      \ I vector to positive and [10110]\n        spi.xfer2([ADDR, 0x25, 0x20])  #\
      \ Sets Tx3 Q vector to positive and [10110]\n        spi.xfer2([ADDR, 0x1F,\
      \ 128])  # Sets Tx4 gain\n        spi.xfer2([ADDR, 0x26, 0x3F])  # Sets Tx4\
      \ I vector to positive and [10110]\n        spi.xfer2([ADDR, 0x27, 0x20])  #\
      \ Sets Tx4 Q vector to positive and [10110]\n\n        spi.xfer2([ADDR, 0x28,\
      \ 0x02])  # Loads Tx vectors from SPI.\n\n        spi.xfer2([ADDR, 0x31, 0xD2])\
      \  # Put part into Tx mode (bit 1=High).  TR_SW_POS should be 0V and PA bias\
      \ should be -1.1V.\n\n    time.sleep(0.1)\n\n\ndef ADAR_set_RxTaper(spi, ADDR,\
      \ Rx_mode, RxGain1, RxGain2, RxGain3, RxGain4):\n    # set the ADAR1000's VGA\
      \ gain of each of the Rx channels.  RxGainx needs to be between 0 and 127\n\
      \    if Rx_mode == 1:\n        spi.xfer2([ADDR, 0x10, int(128+RxGain1)])  #\
      \ Sets Rx1 VGA gain\n        spi.xfer2([ADDR, 0x11, int(128+RxGain2)])  # Sets\
      \ Rx2 VGA gain\n        spi.xfer2([ADDR, 0x12, int(128+RxGain3)])  # Sets Rx3\
      \ VGA gain\n        spi.xfer2([ADDR, 0x13, int(128+RxGain4)])  # Sets Rx4 VGA\
      \ gain\n    else:\n        spi.xfer2([ADDR, 0x1C, int(128+RxGain1)])  # Sets\
      \ Tx1 VGA gain\n        spi.xfer2([ADDR, 0x1D, int(128+RxGain2)])  # Sets Tx2\
      \ VGA gain\n        spi.xfer2([ADDR, 0x1E, int(128+RxGain3)])  # Sets Tx3 VGA\
      \ gain\n        spi.xfer2([ADDR, 0x1F, int(128+RxGain4)])  # Sets Tx4 VGA gain\n\
      \        #print(\"TX mode, ADDR = \", ADDR, RxGain1, RxGain2, RxGain3, RxGain4)\n\
      \        spi.xfer2([ADDR, 0x31, 0xD2])  # Put part into Tx mode (bit 1=High).\
      \  TR_SW_POS should be 0V and PA bias should be -1.1V.\n\n    if Rx_mode ==\
      \ 1:\n        spi.xfer2([ADDR, 0x28, 0x01])  # Loads Rx vectors from SPI.  0x08\
      \ is all ADAR1000 devices\n    else:\n        spi.xfer2([ADDR, 0x28, 0x02])\
      \  # Loads Tx vectors from SPI.  0x08 is all ADAR1000 devices\n        \ndef\
      \ ADAR_set_RxPhase(spi, address, num_ADARs, Rx_mode, PhDelta, phase_step_size,\
      \ RxPhase1, RxPhase2, RxPhase3, RxPhase4):\n    step_size = 360  #2.8125\n \
      \   Phase_A = ((np.rint(PhDelta*0/step_size)*step_size) + RxPhase1) % 360\n\
      \    Phase_B = ((np.rint(PhDelta*1/step_size)*step_size) + RxPhase2) % 360\n\
      \    Phase_C = ((np.rint(PhDelta*2/step_size)*step_size) + RxPhase3) % 360\n\
      \    Phase_D = ((np.rint(PhDelta*3/step_size)*step_size) + RxPhase4) % 360\n\
      \    if num_ADARs == 2:\n        Phase_A = ((np.rint(PhDelta*4/step_size)*step_size)\
      \ + RxPhase1) % 360\n        Phase_B = ((np.rint(PhDelta*5/step_size)*step_size)\
      \ + RxPhase2) % 360\n        Phase_C = ((np.rint(PhDelta*6/step_size)*step_size)\
      \ + RxPhase3) % 360\n        Phase_D = ((np.rint(PhDelta*7/step_size)*step_size)\
      \ + RxPhase4) % 360\n    channels = [Phase_A, Phase_B, Phase_C, Phase_D]\n\n\
      \    # Write vector I and Q to set phase shift (see Table 13 in ADAR1000 datasheet)\n\
      \    i=1\n    for Channel_Phase in channels:\n        #round_Phase = np.rint(Channel_Phase/step_size)*step_size\n\
      \        if i==1:\n            if Rx_mode == 1:\n                I = 0x14  \
      \ # Rx1_I vector register address = 0x14\n                Q = 0x15   # Rx1_Q\
      \ vector register address = 0x15\n            else:\n                I = 0x20\
      \   # Tx1\n                Q = 0x21   # Tx1\n        if i==2:\n            if\
      \ Rx_mode == 1:\n                I = 0x16   # Rx2_I vector register address\
      \ = 0x16\n                Q = 0x17   # Rx2_Q vector register address = 0x17\n\
      \            else:\n                I = 0x22   # Tx2\n                Q = 0x23\
      \   # Tx2\n        if i==3:\n            if Rx_mode == 1:\n                I\
      \ = 0x18   # Rx3_I vector register address = 0x18\n                Q = 0x19\
      \   # Rx3_Q vector register address = 0x19\n            else:\n            \
      \    I = 0x24   # Tx3\n                Q = 0x25   # Tx3\n        if i==4:\n\
      \            if Rx_mode == 1:\n                I = 0x1A   # Rx4_I vector register\
      \ address = 0x1A\n                Q = 0x1B   # Rx4_Q vector register address\
      \ = 0x1B\n            else:\n                I = 0x26   # Tx4\n            \
      \    Q = 0x27   # Tx4\n        \n        ADAR_write_RxPhase(spi, address, Channel_Phase,\
      \ I, Q)\n        i = i+1\n    if Rx_mode == 1:\n        spi.xfer2([address,\
      \ 0x28, 0x01])  # Loads Rx vectors from SPI.  0x08 is all ADAR1000 devices\n\
      \    else:\n        spi.xfer2([address, 0x28, 0x02])  # Loads Tx vectors from\
      \ SPI.  0x08 is all ADAR1000 devices\n\ndef ADAR_write_RxPhase(spi, ADDR, Channel_Phase,\
      \ I, Q):\n    # See Table 13 in the ADAR1000 datasheet\n    # Quadrant 1\n \
      \   if Channel_Phase==0:\n        spi.xfer2([ADDR, I, 0x3F])\n        spi.xfer2([ADDR,\
      \ Q, 0x20])\n    if Channel_Phase==2.8125:\n        spi.xfer2([ADDR, I, 0x3F])\n\
      \        spi.xfer2([ADDR, Q, 0x21])\n    if Channel_Phase==5.625:\n        spi.xfer2([ADDR,\
      \ I, 0x3F])\n        spi.xfer2([ADDR, Q, 0x23])\n    if Channel_Phase==8.4375:\n\
      \        spi.xfer2([ADDR, I, 0x3F])\n        spi.xfer2([ADDR, Q, 0x24])\n  \
      \  if Channel_Phase==11.25:\n        spi.xfer2([ADDR, I, 0x3F])\n        spi.xfer2([ADDR,\
      \ Q, 0x26])\n    if Channel_Phase==14.0625:\n        spi.xfer2([ADDR, I, 0x3E])\n\
      \        spi.xfer2([ADDR, Q, 0x27])\n    if Channel_Phase==16.875:\n       \
      \ spi.xfer2([ADDR, I, 0x3E])\n        spi.xfer2([ADDR, Q, 0x28])\n    if Channel_Phase==19.6875:\n\
      \        spi.xfer2([ADDR, I, 0x3D])\n        spi.xfer2([ADDR, Q, 0x2A])\n  \
      \  if Channel_Phase==22.5:\n        spi.xfer2([ADDR, I, 0x3D])\n        spi.xfer2([ADDR,\
      \ Q, 0x2B])\n    if Channel_Phase==25.3125:\n        spi.xfer2([ADDR, I, 0x3C])\n\
      \        spi.xfer2([ADDR, Q, 0x2D])\n    if Channel_Phase==28.125:\n       \
      \ spi.xfer2([ADDR, I, 0x3C])\n        spi.xfer2([ADDR, Q, 0x2E])\n    if Channel_Phase==30.9375:\n\
      \        spi.xfer2([ADDR, I, 0x3B])\n        spi.xfer2([ADDR, Q, 0x2F])\n  \
      \  if Channel_Phase==33.75:\n        spi.xfer2([ADDR, I, 0x3A])\n        spi.xfer2([ADDR,\
      \ Q, 0x30])\n    if Channel_Phase==36.5625:\n        spi.xfer2([ADDR, I, 0x39])\n\
      \        spi.xfer2([ADDR, Q, 0x31])\n    if Channel_Phase==39.375:\n       \
      \ spi.xfer2([ADDR, I, 0x38])\n        spi.xfer2([ADDR, Q, 0x33])\n    if Channel_Phase==42.1875:\n\
      \        spi.xfer2([ADDR, I, 0x37])\n        spi.xfer2([ADDR, Q, 0x34])\n  \
      \  if Channel_Phase==45:\n        spi.xfer2([ADDR, I, 0x36])\n        spi.xfer2([ADDR,\
      \ Q, 0x35])\n    if Channel_Phase==47.8125:\n        spi.xfer2([ADDR, I, 0x35])\n\
      \        spi.xfer2([ADDR, Q, 0x36])\n    if Channel_Phase==50.625:\n       \
      \ spi.xfer2([ADDR, I, 0x34])\n        spi.xfer2([ADDR, Q, 0x37])\n    if Channel_Phase==53.4375:\n\
      \        spi.xfer2([ADDR, I, 0x33])\n        spi.xfer2([ADDR, Q, 0x38])\n  \
      \  if Channel_Phase==56.25:\n        spi.xfer2([ADDR, I, 0x32])\n        spi.xfer2([ADDR,\
      \ Q, 0x38])\n        spi.xfer2([ADDR, Q, 0x39])\n    if Channel_Phase==61.875:\n\
      \        spi.xfer2([ADDR, I, 0x2F])\n        spi.xfer2([ADDR, Q, 0x3A])\n  \
      \  if Channel_Phase==64.6875:\n        spi.xfer2([ADDR, I, 0x2E])\n        spi.xfer2([ADDR,\
      \ Q, 0x3A])\n    if Channel_Phase==67.5:\n        spi.xfer2([ADDR, I, 0x2C])\n\
      \        spi.xfer2([ADDR, Q, 0x3B])\n    if Channel_Phase==70.3125:\n      \
      \  spi.xfer2([ADDR, I, 0x2B])\n        spi.xfer2([ADDR, Q, 0x3C])\n    if Channel_Phase==73.125:\n\
      \        spi.xfer2([ADDR, I, 0x2A])\n        spi.xfer2([ADDR, Q, 0x3C])\n  \
      \  if Channel_Phase==75.9375:\n        spi.xfer2([ADDR, I, 0x28])\n        spi.xfer2([ADDR,\
      \ Q, 0x3C])\n    if Channel_Phase==78.75:\n        spi.xfer2([ADDR, I, 0x27])\n\
      \        spi.xfer2([ADDR, Q, 0x3D])\n    if Channel_Phase==81.5625:\n      \
      \  spi.xfer2([ADDR, I, 0x25])\n        spi.xfer2([ADDR, Q, 0x3D])\n    if Channel_Phase==84.375:\n\
      \        spi.xfer2([ADDR, I, 0x24])\n        spi.xfer2([ADDR, Q, 0x3D])\n  \
      \  if Channel_Phase==87.1875:\n        spi.xfer2([ADDR, I, 0x22])\n        spi.xfer2([ADDR,\
      \ Q, 0x3D])\n# Quadrant 2\n    if Channel_Phase==90:\n        spi.xfer2([ADDR,\
      \ I, 0x21])\n        spi.xfer2([ADDR, Q, 0x3D])\n    if Channel_Phase==92.8125:\n\
      \        spi.xfer2([ADDR, I, 0x01])\n        spi.xfer2([ADDR, Q, 0x3D])\n  \
      \  if Channel_Phase==95.625:\n        spi.xfer2([ADDR, I, 0x03])\n        spi.xfer2([ADDR,\
      \ Q, 0x3D])\n    if Channel_Phase==98.4375:\n        spi.xfer2([ADDR, I, 0x04])\n\
      \        spi.xfer2([ADDR, Q, 0x3D])\n    if Channel_Phase==101.25:\n       \
      \ spi.xfer2([ADDR, I, 0x06])\n        spi.xfer2([ADDR, Q, 0x3D])\n    if Channel_Phase==104.0625:\n\
      \        spi.xfer2([ADDR, I, 0x07])\n        spi.xfer2([ADDR, Q, 0x3C])\n  \
      \  if Channel_Phase==106.875:\n        spi.xfer2([ADDR, I, 0x08])\n        spi.xfer2([ADDR,\
      \ Q, 0x3C])\n    if Channel_Phase==109.6875:\n        spi.xfer2([ADDR, I, 0x0A])\n\
      \        spi.xfer2([ADDR, Q, 0x3C])\n    if Channel_Phase==112.5:\n        spi.xfer2([ADDR,\
      \ I, 0x0B])\n        spi.xfer2([ADDR, Q, 0x3B])\n    if Channel_Phase==115.3125:\n\
      \        spi.xfer2([ADDR, I, 0x0D])\n        spi.xfer2([ADDR, Q, 0x3A])\n  \
      \  if Channel_Phase==118.125:\n        spi.xfer2([ADDR, I, 0x0E])\n        spi.xfer2([ADDR,\
      \ Q, 0x3A])\n    if Channel_Phase==120.9375:\n        spi.xfer2([ADDR, I, 0x0F])\n\
      \        spi.xfer2([ADDR, Q, 0x39])\n    if Channel_Phase==123.75:\n       \
      \ spi.xfer2([ADDR, I, 0x11])\n        spi.xfer2([ADDR, Q, 0x38])\n    if Channel_Phase==126.5625:\n\
      \        spi.xfer2([ADDR, I, 0x12])\n        spi.xfer2([ADDR, Q, 0x38])\n  \
      \  if Channel_Phase==129.375:\n        spi.xfer2([ADDR, I, 0x13])\n        spi.xfer2([ADDR,\
      \ Q, 0x37])\n    if Channel_Phase==132.1875:\n        spi.xfer2([ADDR, I, 0x14])\n\
      \        spi.xfer2([ADDR, Q, 0x36])\n    if Channel_Phase==135:\n        spi.xfer2([ADDR,\
      \ I, 0x16])\n        spi.xfer2([ADDR, Q, 0x35])\n    if Channel_Phase==137.8125:\n\
      \        spi.xfer2([ADDR, I, 0x17])\n        spi.xfer2([ADDR, Q, 0x34])\n  \
      \  if Channel_Phase==140.625:\n        spi.xfer2([ADDR, I, 0x18])\n        spi.xfer2([ADDR,\
      \ Q, 0x33])\n    if Channel_Phase==143.4375:\n        spi.xfer2([ADDR, I, 0x19])\n\
      \        spi.xfer2([ADDR, Q, 0x31])\n    if Channel_Phase==146.25:\n       \
      \ spi.xfer2([ADDR, I, 0x19])\n        spi.xfer2([ADDR, Q, 0x30])\n    if Channel_Phase==149.0625:\n\
      \        spi.xfer2([ADDR, I, 0x1A])\n        spi.xfer2([ADDR, Q, 0x2F])\n  \
      \  if Channel_Phase==151.875:\n        spi.xfer2([ADDR, I, 0x1B])\n        spi.xfer2([ADDR,\
      \ Q, 0x2E])\n    if Channel_Phase==154.6875:\n        spi.xfer2([ADDR, I, 0x1C])\n\
      \        spi.xfer2([ADDR, Q, 0x2D])\n    if Channel_Phase==157.5:\n        spi.xfer2([ADDR,\
      \ I, 0x1C])\n        spi.xfer2([ADDR, Q, 0x2B])\n    if Channel_Phase==160.3125:\n\
      \        spi.xfer2([ADDR, I, 0x1D])\n        spi.xfer2([ADDR, Q, 0x2A])\n  \
      \  if Channel_Phase==163.125:\n        spi.xfer2([ADDR, I, 0X1E])\n        spi.xfer2([ADDR,\
      \ Q, 0x28])\n    if Channel_Phase==165.9375:\n        spi.xfer2([ADDR, I, 0x1E])\n\
      \        spi.xfer2([ADDR, Q, 0x27])\n    if Channel_Phase==168.75:\n       \
      \ spi.xfer2([ADDR, I, 0x1E])\n        spi.xfer2([ADDR, Q, 0x26])\n    if Channel_Phase==171.5625:\n\
      \        spi.xfer2([ADDR, I, 0x1F])\n        spi.xfer2([ADDR, Q, 0x24])\n  \
      \  if Channel_Phase==174.375:\n        spi.xfer2([ADDR, I, 0x1F])\n        spi.xfer2([ADDR,\
      \ Q, 0x23])\n    if Channel_Phase==177.1875:\n        spi.xfer2([ADDR, I, 0x1F])\n\
      \        spi.xfer2([ADDR, Q, 0x21])\n# Quadrant 3\n    if Channel_Phase==180:\n\
      \        spi.xfer2([ADDR, I, 0x1F])\n        spi.xfer2([ADDR, Q, 0x20])\n  \
      \  if Channel_Phase==182.8125:\n        spi.xfer2([ADDR, I, 0x1F])\n       \
      \ spi.xfer2([ADDR, Q, 0x20])\n    if Channel_Phase==185.625:\n        spi.xfer2([ADDR,\
      \ I, 0x1F])\n        spi.xfer2([ADDR, Q, 0x03])\n    if Channel_Phase==188.4375:\n\
      \        spi.xfer2([ADDR, I, 0x1F])\n        spi.xfer2([ADDR, Q, 0x04])\n  \
      \  if Channel_Phase==191.25:\n        spi.xfer2([ADDR, I, 0x1F])\n        spi.xfer2([ADDR,\
      \ Q, 0x06])\n    if Channel_Phase==194.0625:\n        spi.xfer2([ADDR, I, 0x1E])\n\
      \        spi.xfer2([ADDR, Q, 0x07])\n    if Channel_Phase==196.875:\n      \
      \  spi.xfer2([ADDR, I, 0x1E])\n        spi.xfer2([ADDR, Q, 0x08])\n    if Channel_Phase==199.6875:\n\
      \        spi.xfer2([ADDR, I, 0x1D])\n        spi.xfer2([ADDR, Q, 0x0A])\n  \
      \  if Channel_Phase==202.5:\n        spi.xfer2([ADDR, I, 0x1D])\n        spi.xfer2([ADDR,\
      \ Q, 0x0B])\n    if Channel_Phase==205.3125:\n        spi.xfer2([ADDR, I, 0x1C])\n\
      \        spi.xfer2([ADDR, Q, 0x0D])\n    if Channel_Phase==208.125:\n      \
      \  spi.xfer2([ADDR, I, 0x1C])\n        spi.xfer2([ADDR, Q, 0x0E])\n    if Channel_Phase==210.9375:\n\
      \        spi.xfer2([ADDR, I, 0x1B])\n        spi.xfer2([ADDR, Q, 0x0F])\n  \
      \  if Channel_Phase==213.75:\n        spi.xfer2([ADDR, I, 0x1A])\n        spi.xfer2([ADDR,\
      \ Q, 0x10])\n    if Channel_Phase==216.5625:\n        spi.xfer2([ADDR, I, 0x19])\n\
      \        spi.xfer2([ADDR, Q, 0x11])\n    if Channel_Phase==219.375:\n      \
      \  spi.xfer2([ADDR, I, 0x18])\n        spi.xfer2([ADDR, Q, 0x13])\n    if Channel_Phase==222.1875:\n\
      \        spi.xfer2([ADDR, I, 0x17])\n        spi.xfer2([ADDR, Q, 0x14])\n  \
      \  if Channel_Phase==225:\n        spi.xfer2([ADDR, I, 0x16])\n        spi.xfer2([ADDR,\
      \ Q, 0x15])\n    if Channel_Phase==227.8125:\n        spi.xfer2([ADDR, I, 0x15])\n\
      \        spi.xfer2([ADDR, Q, 0x16])\n    if Channel_Phase==230.625:\n      \
      \  spi.xfer2([ADDR, I, 0x14])\n        spi.xfer2([ADDR, Q, 0x17])\n    if Channel_Phase==233.4375:\n\
      \        spi.xfer2([ADDR, I, 0x13])\n        spi.xfer2([ADDR, Q, 0x18])\n  \
      \  if Channel_Phase==236.25:\n        spi.xfer2([ADDR, I, 0x12])\n        spi.xfer2([ADDR,\
      \ Q, 0x18])\n    if Channel_Phase==239.0625:\n        spi.xfer2([ADDR, I, 0x10])\n\
      \        spi.xfer2([ADDR, Q, 0x19])\n    if Channel_Phase==241.875:\n      \
      \  spi.xfer2([ADDR, I, 0x0F])\n        spi.xfer2([ADDR, Q, 0x1A])\n    if Channel_Phase==244.6875:\n\
      \        spi.xfer2([ADDR, I, 0x0E])\n        spi.xfer2([ADDR, Q, 0x1A])\n  \
      \  if Channel_Phase==247.5:\n        spi.xfer2([ADDR, I, 0x0C])\n        spi.xfer2([ADDR,\
      \ Q, 0x1B])\n    if Channel_Phase==250.3125:\n        spi.xfer2([ADDR, I, 0x0B])\n\
      \        spi.xfer2([ADDR, Q, 0x1C])\n    if Channel_Phase==253.125:\n      \
      \  spi.xfer2([ADDR, I, 0x0A])\n        spi.xfer2([ADDR, Q, 0x1C])\n    if Channel_Phase==255.9375:\n\
      \        spi.xfer2([ADDR, I, 0x08])\n        spi.xfer2([ADDR, Q, 0x1C])\n  \
      \  if Channel_Phase==258.75:\n        spi.xfer2([ADDR, I, 0x07])\n        spi.xfer2([ADDR,\
      \ Q, 0x1D])\n    if Channel_Phase==261.5625:\n        spi.xfer2([ADDR, I, 0x05])\n\
      \        spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==264.375:\n      \
      \  spi.xfer2([ADDR, I, 0x04])\n        spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==267.1875:\n\
      \        spi.xfer2([ADDR, I, 0x02])\n        spi.xfer2([ADDR, Q, 0x1D])\n# Quadrant\
      \ 4\n    if Channel_Phase==270:\n        spi.xfer2([ADDR, I, 0x01])\n      \
      \  spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==272.8125:\n        spi.xfer2([ADDR,\
      \ I, 0x21])\n        spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==275.625:\n\
      \        spi.xfer2([ADDR, I, 0x23])\n        spi.xfer2([ADDR, Q, 0x1D])\n  \
      \  if Channel_Phase==278.4375:\n        spi.xfer2([ADDR, I, 0x24])\n       \
      \ spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==281.25:\n        spi.xfer2([ADDR,\
      \ I, 0x26])\n        spi.xfer2([ADDR, Q, 0x1D])\n    if Channel_Phase==284.0625:\n\
      \        spi.xfer2([ADDR, I, 0x27])\n        spi.xfer2([ADDR, Q, 0x1C])\n  \
      \  if Channel_Phase==286.875:\n        spi.xfer2([ADDR, I, 0x28])\n        spi.xfer2([ADDR,\
      \ Q, 0x1C])\n    if Channel_Phase==289.6875:\n        spi.xfer2([ADDR, I, 0x2A])\n\
      \        spi.xfer2([ADDR, Q, 0x1C])\n    if Channel_Phase==292.5:\n        spi.xfer2([ADDR,\
      \ I, 0x2B])\n        spi.xfer2([ADDR, Q, 0x1B])\n    if Channel_Phase==295.3125:\n\
      \        spi.xfer2([ADDR, I, 0x2D])\n        spi.xfer2([ADDR, Q, 0x1A])\n  \
      \  if Channel_Phase==298.125:\n        spi.xfer2([ADDR, I, 0x2E])\n        spi.xfer2([ADDR,\
      \ Q, 0x1A])\n    if Channel_Phase==300.9375:\n        spi.xfer2([ADDR, I, 0x2F])\n\
      \        spi.xfer2([ADDR, Q, 0x19])\n    if Channel_Phase==303.75:\n       \
      \ spi.xfer2([ADDR, I, 0x31])\n        spi.xfer2([ADDR, Q, 0x18])\n    if Channel_Phase==306.5625:\n\
      \        spi.xfer2([ADDR, I, 0x32])\n        spi.xfer2([ADDR, Q, 0x18])\n  \
      \  if Channel_Phase==309.375:\n        spi.xfer2([ADDR, I, 0x33])\n        spi.xfer2([ADDR,\
      \ Q, 0x17])\n    if Channel_Phase==312.1875:\n        spi.xfer2([ADDR, I, 0x34])\n\
      \        spi.xfer2([ADDR, Q, 0x16])\n    if Channel_Phase==315:\n        spi.xfer2([ADDR,\
      \ I, 0x36])\n        spi.xfer2([ADDR, Q, 0x15])\n    if Channel_Phase==317.8125:\n\
      \        spi.xfer2([ADDR, I, 0x37])\n        spi.xfer2([ADDR, Q, 0x14])\n  \
      \  if Channel_Phase==320.625:\n        spi.xfer2([ADDR, I, 0x38])\n        spi.xfer2([ADDR,\
      \ Q, 0x13])\n    if Channel_Phase==323.4375:\n        spi.xfer2([ADDR, I, 0x39])\n\
      \        spi.xfer2([ADDR, Q, 0x11])\n    if Channel_Phase==326.25:\n       \
      \ spi.xfer2([ADDR, I, 0x39])\n        spi.xfer2([ADDR, Q, 0x10])\n    if Channel_Phase==329.0625:\n\
      \        spi.xfer2([ADDR, I, 0x3A])\n        spi.xfer2([ADDR, Q, 0x0F])\n  \
      \  if Channel_Phase==331.875:\n        spi.xfer2([ADDR, I, 0x3B])\n        spi.xfer2([ADDR,\
      \ Q, 0x0E])\n    if Channel_Phase==334.6875:\n        spi.xfer2([ADDR, I, 0x3C])\n\
      \        spi.xfer2([ADDR, Q, 0x0D])\n    if Channel_Phase==337.5:\n        spi.xfer2([ADDR,\
      \ I, 0x3C])\n        spi.xfer2([ADDR, Q, 0x0B])\n    if Channel_Phase==340.3125:\n\
      \        spi.xfer2([ADDR, I, 0x3D])\n        spi.xfer2([ADDR, Q, 0x0A])\n  \
      \  if Channel_Phase==343.125:\n        spi.xfer2([ADDR, I, 0x3E])\n        spi.xfer2([ADDR,\
      \ Q, 0x08])\n    if Channel_Phase==345.9375:\n        spi.xfer2([ADDR, I, 0x3E])\n\
      \        spi.xfer2([ADDR, Q, 0x07])\n    if Channel_Phase==348.75:\n       \
      \ spi.xfer2([ADDR, I, 0x3E])\n        spi.xfer2([ADDR, Q, 0x06])\n    if Channel_Phase==351.5625:\n\
      \        spi.xfer2([ADDR, I, 0x3F])\n        spi.xfer2([ADDR, Q, 0x04])\n  \
      \  if Channel_Phase==354.375:\n        spi.xfer2([ADDR, I, 0x3F])\n        spi.xfer2([ADDR,\
      \ Q, 0x03])\n    if Channel_Phase==357.1875:\n        spi.xfer2([ADDR, I, 0x3F])\n\
      \        spi.xfer2([ADDR, Q, 0x01])\n\n\nclass blk(gr.sync_block):  # other\
      \ base classes are basic_block, decim_block, interp_block\n\n    def __init__(self,\
      \ addr=0, reprogram=0, rx_en=1, Taper=1, SymTaper=0, PhaseCal=0, SignalFreq=10525000000,\
      \ RxGain1=127, RxGain2=127, RxGain3=127, RxGain4=127, Rx1_cal=0, Rx2_cal=0,\
      \ Rx3_cal=0, Rx4_cal=0):  \n        \"\"\"arguments to this function show up\
      \ as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n            self,\n\
      \            name='ADAR1000 Sweeper',   # will show up in GRC\n            in_sig=[],\n\
      \            out_sig=[np.complex64, np.float32]\n        )\n        self.addr\
      \ = addr\n        self.rx_en = rx_en   # set to 1 for ADAR1000 Rx mode, or 0\
      \ for ADAR1000 Tx mode\n        self.reprogram = reprogram\n\n        self.Taper\
      \ = Taper\n        self.SymTaper = SymTaper\n        self.PhaseCal = PhaseCal\n\
      \        self.RxGain1 = RxGain1\n        self.RxGain2 = RxGain2\n        self.RxGain3\
      \ = RxGain3\n        self.RxGain4 = RxGain4\n        self.Rx1_cal=Rx1_cal\n\
      \        self.Rx2_cal=Rx2_cal\n        self.Rx3_cal=Rx3_cal\n        self.Rx4_cal=Rx4_cal\n\
      \                       \n        self.spi = spidev.SpiDev()\n        self.spi.open(0,\
      \ 0)  #set bus=0 and device=0\n        self.spi.max_speed_hz = 500000\n    \
      \    self.spi.mode = 0\n\n        # The ADDR is set by the address pins on the\
      \ ADAR1000\n        if self.addr == 0:\n            self.ADDR1=0x00        \
      \    \n        if self.addr == 1:\n            self.ADDR1=0x20\n        if self.addr\
      \ == 2:\n            self.ADDR1=0x40\n        if self.addr == 3:\n         \
      \   self.ADDR1=0x60\n            \n        ADAR_init(self.spi, self.ADDR1, self.rx_en)\n\
      \        \n\n\n    def work(self, input_items, output_items):\n        # The\
      \ ADDR is set by the address pins on the ADAR1000\n        if self.addr == 0:\n\
      \            self.ADDR1=0x00            \n        if self.addr == 1:\n     \
      \       self.ADDR1=0x20\n        if self.addr == 2:\n            self.ADDR1=0x40\n\
      \        if self.addr == 3:\n            self.ADDR1=0x60\n\n        if self.reprogram\
      \ == 1:\n            print(\"reprogram\")\n            ADAR_init(self.spi, self.ADDR1,\
      \ self.rx_en)\n        \n        time.sleep(0.1)\n\n        if self.Taper==0:\n\
      \            if self.SymTaper==0:\n                Gain4=self.RxGain4  # Sets\
      \ Rx4 VGA gain\n            else:\n                Gain4=self.RxGain1  # Sets\
      \ Rx4 VGA gain\n            ADAR_set_RxTaper(self.spi, self.ADDR1, self.rx_en,\
      \ self.RxGain1, self.RxGain2, self.RxGain3, Gain4)\n        else:\n        \
      \    ADAR_set_RxTaper(self.spi, self.ADDR1, self.rx_en, 127, 127, 127, 127)\n\
      \        \n        if self.PhaseCal == 0:\n            Rx1_Phase_Cal = self.Rx1_cal\n\
      \            Rx2_Phase_Cal = self.Rx2_cal\n            Rx3_Phase_Cal = self.Rx3_cal\n\
      \            Rx4_Phase_Cal = self.Rx4_cal\n        else:\n            Rx1_Phase_Cal\
      \ = 0\n            Rx2_Phase_Cal = 0\n            Rx3_Phase_Cal = 0\n      \
      \      Rx4_Phase_Cal = 0\n\n        PhaseValues = np.arange(0, 1, 1)   \n  \
      \      PhaseStepNumber=0    # this is the number of phase steps we'll take (140\
      \ in total).  At each phase step, we set the individual phases of each of the\
      \ Rx channels\n        for PhDelta in PhaseValues:\n            ADAR_set_RxPhase(self.spi,\
      \ self.ADDR1, 1, self.rx_en, 0, 360, Rx1_Phase_Cal, Rx2_Phase_Cal, Rx3_Phase_Cal,\
      \ Rx4_Phase_Cal)               \n            output_items[0][PhaseStepNumber]=((1)\
      \ + (1j))  # output this as a complex number so we can do an x-y plot with the\
      \ constellation graph\n            PhaseStepNumber=PhaseStepNumber+1    # increment\
      \ the phase delta and start this whole thing again.  This will repeat 140 times\n\
      \        output_items[0]=output_items[0][0:PhaseStepNumber]\n        output_items[1][:]\
      \ = 1\n        \n        return len(output_items[0])\n"
    addr: int(ADAR_address)
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    reprogram: int(Setup_ADAR1000)
    rx_en: ADAR_mode
  states:
    _io_cache: ('ADAR1000 Sweeper', 'blk', [('addr', '0'), ('reprogram', '0'), ('rx_en',
      '1'), ('Taper', '1'), ('SymTaper', '0'), ('PhaseCal', '0'), ('SignalFreq', '10525000000'),
      ('RxGain1', '127'), ('RxGain2', '127'), ('RxGain3', '127'), ('RxGain4', '127'),
      ('Rx1_cal', '0'), ('Rx2_cal', '0'), ('Rx3_cal', '0'), ('Rx4_cal', '0')], [],
      [('0', 'complex', 1), ('1', 'float', 1)], 'arguments to this function show up
      as parameters in GRC', ['PhaseCal', 'Rx1_cal', 'Rx2_cal', 'Rx3_cal', 'Rx4_cal',
      'RxGain1', 'RxGain2', 'RxGain3', 'RxGain4', 'SymTaper', 'Taper', 'addr', 'reprogram',
      'rx_en'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [22, 298]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"red"'
    color4: '"red"'
    color5: '"red"'
    color6: '"red"'
    color7: '"red"'
    color8: '"red"'
    color9: '"red"'
    comment: ''
    grid: 'True'
    gui_hint: 0,2,5,3
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'False'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Peak Signal vs Steering Angle"'
    nconnections: '1'
    size: '140'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '80'
    xmin: '-80'
    ymax: '0'
    ymin: '-50'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [278, 303]
    rotation: 0
    state: enabled

connections:
- [blocks_throttle_0, '0', blocks_null_sink_0, '0']
- [epy_block_0, '0', qtgui_const_sink_x_0, '0']
- [epy_block_0, '1', blocks_throttle_0, '0']

metadata:
  file_format: 1
